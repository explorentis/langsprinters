#langsprinters#

##Краткое описание##

Данный репозиторий - это соревнование программ, написанных на разных языках и/или используя разные алгоритмы, но выполняющих одну поставленную задачу.

##Зачем я это затеял:##

Просто так. Показатели времени, полученные здесь не могут служить точным критерием производительности того или иного языка, т.к. постановка задачи не затрагивают слишком многих аспектов языка, но примерное соотношение скоростей выполнения языков/алгоритмов, выполняющих одну и ту же задачу, оценить можно.

##Задача:##

Задача, поставленная на данный момент - это проверка чисел на то, являются ли они числами Армстронга.

Число Армстронга (самовлюбленное число) - это число, равное сумме своих цифр, возведенных в степень, равную количеству цифр. Подробнее о них можно почитать например здесь:
[http://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%90%D1%80%D0%BC%D1%81%D1%82%D1%80%D0%BE%D0%BD%D0%B3%D0%B0](http://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%90%D1%80%D0%BC%D1%81%D1%82%D1%80%D0%BE%D0%BD%D0%B3%D0%B0)

###Почему я выбрал именно его:###
1. Числа Армстронга - это натуральные числа. Нет проблем с натуральными числами при реализации на (например) brainfuck'е
2. Алгоритм (по крайней мере тот, который известен мне) проверяет все числа, а не вычисляет следующее число Армстронга. Поэтому получаемые значения не слишком быстро растут, а значит не обязательно использовать длинную арифметику - проще для реализаций на c, brainfuck'е и т.п.
3. Простейший алгоритм прост и понятен для понимания.

##Требования к коду##

Для того, чтобы добавить свой вариант решения выполните следующие требования:

- Результаты должны выводиться в стандартный вывод (stdout), в виде
"%d is narcissistic number\n", где %d - число, которое оказалось числом Армстронга
- Желательно, чтобы программа могла принимать аргумент из командной строки. В этом случае передаваемым аргументом является число, до которого следует проверять числа.
- Программа не должна требовать участия пользователя
- <strike>Исходник должен состоять из одного файла.</strike> В настоящий момент можно создать папку в том же каталоге, что и исходник и импортировать оттуда.
- Не хитрить (например, просто выводя уже готовые значения, не вычисляя их)
- Вычисление времени выполнения в программе не требуются - для этого используется утилита time.

Когда все условия соблюдены, можно добавить программу в репозиторий:

* Скопируйте исходный код в соответствующую папку репозитория.
* Если она написана на языке, на котором еще не было реализовано алгоритмов или же хотите запускать интерпретатор (или компилятор в случае компилируемых языков) с отличными от имеющихся, опциями, добавьте соответствующую строку в файл languages.list в формате <имя папки>="строка компиляции или запуска" (все остальное считаем коментарием). Если папка находится в папке interpreted - то файл будет пытаться запуститься, если compiled - то попытается скомпилироваться и затем запуститься.
* Если вы придумали новую реализацию алгоритма, добавьте краткое описание в файл algos.txt в каталоге задачи
* Добавьте строчку в changelog, например
<номер версии, только последнюю цифру увеличиваете на 1>
<пробел>-Добавлена реализация <имя алгоритма> на <язык>, автор: <автор> (S)
* Не забудьте выполнить команды git

Для проверки эффективности всех вариантов запускайте start.sh в каталоге задачи.

##Заметьте##

Прошу не забывать, что при запуске интерпретируемых языков (python, bash) запускаются сами интрепретаторы, которые читают и выполняют переданные файлы, поэтому размер процесса (и скорость выполнения), вероятно, будет зависить от версии и сборки самих интрепретаторов больше, чем от написанного исходного кода. В тоже время при запуске скомпилированных приложений размер и скорость выполнения будет зависить от параметров компиляции.
